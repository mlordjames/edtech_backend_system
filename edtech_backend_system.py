# -*- coding: utf-8 -*-
"""EdTech Backend System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tiWcfEAxAhS2NXWyh4kL54KUjpzrUxUA
"""

import getpass
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
import re
import uuid

#Step1: Create a User Class

EMAIL_RE = re.compile(r"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$")


def valid_email(email: str) -> bool:
    return bool(EMAIL_RE.match(email.strip()))


def require_nonempty(value: str, field_name: str) -> str:
    v = value.strip()
    if not v:
        raise ValueError(f"{field_name} cannot be empty.")
    return v

# Design the User class with specified attributes and methods
# Implement methods to update the email and password and validate credentials

class User:

    def __init__(self, name: str, email: str, password: str, role: str = "learner"):
        self.user_id: str = str(uuid.uuid4())
        self.name: str = require_nonempty(name, "Name")
        if not valid_email(email):
            raise ValueError("Invalid email format.")
        self.email: str = email.strip().lower()
        self._password: str = require_nonempty(password, "Password")
        self.role: str = require_nonempty(role, "Role").lower()

    # Credential methods
    def update_email(self, new_email: str) -> None:
        if not valid_email(new_email):
            raise ValueError("Invalid email format.")
        self.email = new_email.strip().lower()

    def update_password(self, old_password: str, new_password: str) -> None:
        if old_password != self._password:
            raise PermissionError("Old password is incorrect.")
        self._password = require_nonempty(new_password, "New password")

    def validate_credentials(self, email: str, password: str) -> bool:
        return self.email == email.strip().lower() and self._password == password

    def __repr__(self) -> str:
        return f"<User {self.user_id[:8]} {self.name} ({self.role})>"

# Create a Learner Class
# Design the Learner class that inherits from the User class
# Implement methods to enroll in and drop courses

class Learner(User):

    def __init__(self, name: str, email: str, password: str):
        super().__init__(name, email, password, role="learner")
        self.enrolled_courses: Set[str] = set()  # course_ids

    def enroll(self, course_id: str) -> None:
        self.enrolled_courses.add(course_id)

    def drop(self, course_id: str) -> None:
        self.enrolled_courses.discard(course_id)

# Define an Instructor Class:
'''
• Design the Instructor class that inherits from the User class
• Implement methods to add and remove courses taught by the instructor
'''
class Instructor(User):

    def __init__(self, name: str, email: str, password: str):
        super().__init__(name, email, password, role="instructor")
        self.courses_taught: Set[str] = set()  # course_ids

    def add_course(self, course_id: str) -> None:
        self.courses_taught.add(course_id)

    def remove_course(self, course_id: str) -> None:
        self.courses_taught.discard(course_id)

# Define a Course Class
'''
 Design the Course class with specified attributes and methods
 Implement methods to add, remove, and list learners
'''
@dataclass
class Course:

    title: str
    description: str
    instructor_id: Optional[str] = None
    course_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    learners: Set[str] = field(default_factory=set)  # user_ids of learners

    def add_learner(self, learner_id: str) -> None:
        self.learners.add(learner_id)

    def remove_learner(self, learner_id: str) -> None:
        self.learners.discard(learner_id)

    def list_learners(self) -> List[str]:
        return sorted(self.learners)


# Create an Enrollment Class
"""
• Design the Enrollment class with specified attributes and methods
• Implement methods to manage course enrollments

"""
@dataclass
class Enrollment:
    learner_id: str
    course_id: str
    status: str = "active"
    enrollment_id: str = field(default_factory=lambda: str(uuid.uuid4()))

    def drop(self) -> None:
        self.status = "dropped"

    def complete(self) -> None:
        self.status = "completed"


# ───────────────────────────────────────────────────────────────────────────────
# Backend Orchestrator
# ───────────────────────────────────────────────────────────────────────────────

"""
• Design the SLTech Backend class with specified attributes and methods
• Implement methods to manage users, courses, and enrollments
• Implement methods to retrieve enrolled learners and courses

"""

class SLTechBackend:

    def __init__(self) -> None:
        self.users_by_id: Dict[str, User] = {}
        self.users_by_email: Dict[str, str] = {}  # email -> user_id
        self.courses_by_id: Dict[str, Course] = {}
        self.enrollments_by_id: Dict[str, Enrollment] = {}
        # Simple index: (learner_id, course_id) -> enrollment_id
        self.enrollment_index: Dict[tuple[str, str], str] = {}

    # ── Users ──────────────────────────────────────────────────────────────────
    def add_learner(self, name: str, email: str, password: str) -> Learner:
        if email.strip().lower() in self.users_by_email:
            raise ValueError("Email already exists.")
        learner = Learner(name, email, password)
        self._register_user(learner)
        return learner

    def add_instructor(self, name: str, email: str, password: str) -> Instructor:
        if email.strip().lower() in self.users_by_email:
            raise ValueError("Email already exists.")
        instructor = Instructor(name, email, password)
        self._register_user(instructor)
        return instructor

    def _register_user(self, user: User) -> None:
        self.users_by_id[user.user_id] = user
        self.users_by_email[user.email] = user.user_id

    def get_user(self, user_id: str) -> Optional[User]:
        return self.users_by_id.get(user_id)

    def find_user_by_email(self, email: str) -> Optional[User]:
        uid = self.users_by_email.get(email.strip().lower())
        return self.users_by_id.get(uid) if uid else None

    # ── Courses ────────────────────────────────────────────────────────────────
    def add_course(self, title: str, description: str, instructor_id: Optional[str] = None) -> Course:
        course = Course(title=require_nonempty(title, "Course title"),
                        description=require_nonempty(description, "Course description"),
                        instructor_id=instructor_id)
        self.courses_by_id[course.course_id] = course
        if instructor_id:
            inst = self.users_by_id.get(instructor_id)
            if isinstance(inst, Instructor):
                inst.add_course(course.course_id)
        return course

    def remove_course(self, course_id: str) -> None:
        course = self.courses_by_id.pop(course_id, None)
        if not course:
            return
        # Clean from instructor
        if course.instructor_id:
            inst = self.users_by_id.get(course.instructor_id)
            if isinstance(inst, Instructor):
                inst.remove_course(course_id)
        # Drop related enrollments
        to_delete = [eid for eid, e in self.enrollments_by_id.items() if e.course_id == course_id]
        for eid in to_delete:
            self._delete_enrollment(eid)

    def assign_instructor(self, course_id: str, instructor_id: str) -> None:
        course = self.courses_by_id.get(course_id)
        if not course:
            raise KeyError("Course not found.")
        # detach from previous
        if course.instructor_id and course.instructor_id in self.users_by_id:
            prev = self.users_by_id[course.instructor_id]
            if isinstance(prev, Instructor):
                prev.remove_course(course_id)
        # attach to new
        course.instructor_id = instructor_id
        inst = self.users_by_id.get(instructor_id)
        if isinstance(inst, Instructor):
            inst.add_course(course_id)
        else:
            raise ValueError("Instructor id does not refer to an Instructor user.")

    def get_course(self, course_id: str) -> Optional[Course]:
        return self.courses_by_id.get(course_id)

    # ── Enrollments ────────────────────────────────────────────────────────────
    def enroll(self, learner_id: str, course_id: str) -> Enrollment:
        learner = self.users_by_id.get(learner_id)
        course = self.courses_by_id.get(course_id)
        if not isinstance(learner, Learner):
            raise ValueError("Learner id invalid or user is not a learner.")
        if not course:
            raise KeyError("Course not found.")
        key = (learner_id, course_id)
        if key in self.enrollment_index:
            eid = self.enrollment_index[key]
            existing = self.enrollments_by_id[eid]
            if existing.status == "dropped":
                existing.status = "active"
                # reflect on entities
                learner.enroll(course_id)
                course.add_learner(learner_id)
                return existing
            raise ValueError("Learner already enrolled.")
        enrollment = Enrollment(learner_id=learner_id, course_id=course_id)
        self.enrollments_by_id[enrollment.enrollment_id] = enrollment
        self.enrollment_index[key] = enrollment.enrollment_id
        # reflect on entities
        learner.enroll(course_id)
        course.add_learner(learner_id)
        return enrollment

    def drop(self, learner_id: str, course_id: str) -> None:
        key = (learner_id, course_id)
        eid = self.enrollment_index.get(key)
        if not eid:
            raise KeyError("No enrollment found for learner in this course.")
        enrollment = self.enrollments_by_id[eid]
        enrollment.drop()
        # reflect on entities
        learner = self.users_by_id.get(learner_id)
        course = self.courses_by_id.get(course_id)
        if isinstance(learner, Learner):
            learner.drop(course_id)
        if course:
            course.remove_learner(learner_id)

    def _delete_enrollment(self, enrollment_id: str) -> None:
        e = self.enrollments_by_id.pop(enrollment_id, None)
        if not e:
            return
        self.enrollment_index.pop((e.learner_id, e.course_id), None)

    # ── Queries / Reports ──────────────────────────────────────────────────────
    def list_enrolled_learners(self, course_id: str) -> List[User]:
        course = self.courses_by_id.get(course_id)
        if not course:
            raise KeyError("Course not found.")
        return [self.users_by_id[lid] for lid in course.list_learners() if lid in self.users_by_id]

    def list_courses_for_learner(self, learner_id: str) -> List[Course]:
        user = self.users_by_id.get(learner_id)
        if not isinstance(user, Learner):
            raise ValueError("Not a learner.")
        return [self.courses_by_id[cid] for cid in sorted(user.enrolled_courses) if cid in self.courses_by_id]

    def list_courses_for_instructor(self, instructor_id: str) -> List[Course]:
        user = self.users_by_id.get(instructor_id)
        if not isinstance(user, Instructor):
            raise ValueError("Not an instructor.")
        return [self.courses_by_id[cid] for cid in sorted(user.courses_taught) if cid in self.courses_by_id]

    def summary(self) -> str:
        return (
            f"Users: {len(self.users_by_id)} "
            f"(Learners={sum(isinstance(u, Learner) for u in self.users_by_id.values())}, "
            f"Instructors={sum(isinstance(u, Instructor) for u in self.users_by_id.values())}) | "
            f"Courses: {len(self.courses_by_id)} | "
            f"Enrollments: {len(self.enrollments_by_id)}"
        )


# ───────────────────────────────────────────────────────────────────────────────
# Add a User Input Method
# ───────────────────────────────────────────────────────────────────────────────

def prompt_nonempty(label: str) -> str:
    while True:
        v = input(f"{label}: ").strip()
        if v:
            return v
        print("  -> cannot be empty, please try again.")


def menu() -> None:
    backend = SLTechBackend()
    print("=== SL Tech EdTech Backend (In-Memory) ===")
    while True:
        print("\nSelect an option:")
        print(" 1) Add Learner")
        print(" 2) Add Instructor")
        print(" 3) Add Course")
        print(" 4) Assign Instructor to Course")
        print(" 5) Enroll Learner in Course")
        print(" 6) Drop Learner from Course")
        print(" 7) List Enrolled Learners (by Course)")
        print(" 8) List Courses for Learner")
        print(" 9) List Courses for Instructor")
        print("10) Find User by Email & Validate Login")
        print("11) Update User Email")
        print("12) Update User Password")
        print("13) Show Summary")
        print(" 0) Exit")

        choice = input("Enter choice: ").strip()

        try:
            if choice == "1":
                name = prompt_nonempty("Learner Name")
                email = prompt_nonempty("Learner Email")
                password = getpass.getpass("Password (hidden): ")
                learner = backend.add_learner(name, email, password)
                print(f"Created Learner: {learner.name} | id={learner.user_id}")

            elif choice == "2":
                name = prompt_nonempty("Instructor Name")
                email = prompt_nonempty("Instructor Email")
                password = getpass.getpass("Password (hidden): ")
                inst = backend.add_instructor(name, email, password)
                print(f"Created Instructor: {inst.name} | id={inst.user_id}")

            elif choice == "3":
                title = prompt_nonempty("Course Title")
                desc = prompt_nonempty("Course Description")
                print("Optional: Assign instructor now? Leave blank to skip.")
                inst_id = input("Instructor ID: ").strip() or None
                if inst_id and inst_id not in backend.users_by_id:
                    print("  -> Instructor not found, skipping assignment.")
                    inst_id = None
                course = backend.add_course(title, desc, inst_id)
                print(f"Created Course: {course.title} | id={course.course_id}")

            elif choice == "4":
                course_id = prompt_nonempty("Course ID")
                instructor_id = prompt_nonempty("Instructor ID")
                backend.assign_instructor(course_id, instructor_id)
                print("Instructor assigned.")

            elif choice == "5":
                learner_id = prompt_nonempty("Learner ID")
                course_id = prompt_nonempty("Course ID")
                e = backend.enroll(learner_id, course_id)
                print(f"Enrolled. enrollment_id={e.enrollment_id}")

            elif choice == "6":
                learner_id = prompt_nonempty("Learner ID")
                course_id = prompt_nonempty("Course ID")
                backend.drop(learner_id, course_id)
                print("Dropped enrollment.")

            elif choice == "7":
                course_id = prompt_nonempty("Course ID")
                learners = backend.list_enrolled_learners(course_id)
                print(f"Learners in course {course_id}:")
                for u in learners:
                    print(f" - {u.name} ({u.user_id})")

            elif choice == "8":
                learner_id = prompt_nonempty("Learner ID")
                courses = backend.list_courses_for_learner(learner_id)
                print(f"Courses for learner {learner_id}:")
                for c in courses:
                    print(f" - {c.title} ({c.course_id})")

            elif choice == "9":
                instructor_id = prompt_nonempty("Instructor ID")
                courses = backend.list_courses_for_instructor(instructor_id)
                print(f"Courses for instructor {instructor_id}:")
                for c in courses:
                    print(f" - {c.title} ({c.course_id})")

            elif choice == "10":
                email = prompt_nonempty("Email")
                password = getpass.getpass("Password (hidden): ")
                user = backend.find_user_by_email(email)
                if user and user.validate_credentials(email, password):
                    print(f"Login OK: {user.name} ({user.role}) id={user.user_id}")
                else:
                    print("Invalid credentials.")

            elif choice == "11":
                user_id = prompt_nonempty("User ID")
                new_email = prompt_nonempty("New Email")
                user = backend.get_user(user_id)
                if not user:
                    print("User not found.")
                elif new_email.strip().lower() in backend.users_by_email and backend.users_by_email[new_email.strip().lower()] != user_id:
                    print("That email is already in use by another user.")
                else:
                    # update indexes
                    old_email = user.email
                    user.update_email(new_email)
                    backend.users_by_email.pop(old_email, None)
                    backend.users_by_email[user.email] = user_id
                    print("Email updated.")

            elif choice == "12":
                user_id = prompt_nonempty("User ID")
                user = backend.get_user(user_id)
                if not user:
                    print("User not found.")
                else:
                    old_pw = getpass.getpass("Old Password: ")
                    new_pw = getpass.getpass("New Password: ")
                    user.update_password(old_pw, new_pw)
                    print("Password updated.")

            elif choice == "13":
                print(backend.summary())

            elif choice == "0":
                print("Goodbye!")
                return

            else:
                print("Invalid choice. Please try again.")

        except Exception as e:
            print(f"Error: {e}")


if __name__ == "__main__":
    try:
        menu()
    except KeyboardInterrupt:
        print("\nExiting…")